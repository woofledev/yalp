#!/usr/bin/env bash

# -------------------------
#      USER SETTINGS

REPOS=(
    "https://yalpsrv.bcreisepic.repl.co/yalp" # The first repository in this list is the default one
)
PKGDIR=$HOME/yalp 

#   END OF USER SETTINGS
# -------------------------

if [ ! -d "$PKGDIR" ]; then
  mkdir -p "$PKGDIR"
fi

getpkg() {
    mkdir -p $PKGDIR/$1
    cd $PKGDIR/$1
    printf "getting package: $1\n"
    local success=false

    for repo in "${REPOS[@]}"; do
        if curl -sSfO "$repo/pkg/$1.config" > /dev/null 2<&1; then
            success=true
            . $PKGDIR/$1/$1.config
            curl -O "$repo/pkg/$REALNAME"
            break
        else
            printf "\e[33mWARN:\e[0m The repo '$repo' failed to respond.\n"
        fi
    done

    if ! $success; then
        printf "\e[41mERR:\e[0m Failed to download $1.\n"
        rm -rf $PKGDIR/$1
    fi
}

cli_install() {
    pkgs=("$@")
    # its typical to download the package first, and then set everything up.
    for pkg in "${pkgs[@]}"; do
        getpkg "$pkg"
    done
    for pkg in "${pkgs[@]}"; do
        ADDTOPATH="false" # if this isnt set to anything else at start, some packages will be installed to PATH which arent supposed to for some reason.
        if [[ -f "$PKGDIR/$pkg/$pkg.config" ]]; then
            . $PKGDIR/$pkg/$pkg.config
            cd $PKGDIR/$pkg
            printf "\nInstalling $pkg...\n"
            eval "$INSTALL_CMD"
            if [[ "$ADDTOPATH" == "true" ]]; then # ill make this readable later dw
                if command -v grep >/dev/null 2>&1 && ! echo $PATH | grep -q "$PKGDIR/$pkg"; then
                    if [ -n "$BASH_VERSION" ]; then
                        echo "export PATH=\"\$PATH:$PKGDIR/$pkg\"" >> "$HOME/.bashrc"
                        export PATH="$PATH:$PKGDIR/$pkg"
                    elif [ -n "$ZSH_VERSION" ]; then
                        echo "export PATH=\"\$PATH:$PKGDIR/$pkg\"" >> "$HOME/.zshrc"
                        export PATH="$PATH:$PKGDIR/$pkg"
                    fi
                fi
                echo Added $pkg to PATH. You might need to restart your shell for $pkg to work.
            fi
        fi 
    done
}
cli_remove() {
    for pkg in "$@"; do
        . $PKGDIR/$pkg/$pkg.config
        rm -rvf $PKGDIR/$pkg
        eval "$REMOVE_CMD"
    done
}

YALP_VERSION="0.5.5-nightly"
case "$1" in
    install|i)
        if [ $# -lt 2 ]; then
            echo "yalp: missing second argument" >&2
            exit 1
        fi
        cli_install "${@:2}";;
    uninstall|rm)
        if [ $# -lt 2 ]; then
            echo "yalp: missing second argument" >&2
            exit 1
        fi
        cli_remove "${@:2}";;
    run)
        if [ -z "$2" ]; then
            echo "yalp: missing second argument" >&2
            exit 1
        fi
        . $PKGDIR/$2/$2.config
        cd $PKGDIR/$2
        eval "$EXEC_CMD";;
    search)
        if [ -z "$2" ]; then
            echo "yalp: missing second argument" >&2
            exit 1
        fi
        curl -sS $REPOS/search?q=$2;;
    update)
        for f in $(find $PKGDIR -type f -name "*.config"); do
            . $f
            curl -sS $REPOS/pkg/$(basename $f) -o $f.config.new
            OLDPKGVER=$PKGVER
            . $f.config.new
            if [ "$PKGVER" != "$OLDPKGVER" ]; then
                echo $(basename -s .config $f): $OLDPKGVER "=>" $PKGVER
                cli_install $(basename -s .config $f)
            fi
            rm $f.config.new
        done;;
    *)
        printf "yalp v$YALP_VERSION\nvariables:\n   REPO: $REPOS\n   PKGDIR: $PKGDIR\n\n"
        printf "commands:\n   install/i - installs a package\n"
        printf "   uninstall/rm - removes a package\n"
        printf "   run - runs a package (EXEC_CMD from config file)\n"
        printf "   update - (BETA) updates all packages\n"
        printf "   search - searches the repo\n";;
esac